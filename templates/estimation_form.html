<form id="estimation-form" method="POST">
    <input type="hidden" name="csrf_token" value="{{ csrf_token }}">
    <input type="hidden" name="code" value="{{ code }}">
    <input type="hidden" name="method" value="{{ method.lower() }}">

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
        <div>
            <h4>Patient Information</h4>
            <p><strong>Code:</strong> {{ code }}</p>
            <p><strong>Method:</strong> {{ method }}</p>
            <p><strong>Sex:</strong> {{ sex }}</p>

            {% if opg %}
            <div>
                <h4>OPG Image</h4>

                <!-- Large Image Viewer for Better Analysis -->
                <div id="opg-viewer-container"
                    style="position: relative; background: #000; border-radius: 8px; overflow: hidden; border: 2px solid #e2e8f0;">
                    <!-- Zoom Level Indicator -->
                    <div id="zoom-level"
                        style="position: absolute; top: 10px; right: 10px; z-index: 10; background: rgba(0,0,0,0.8); color: white; padding: 6px 12px; border-radius: 4px; font-size: 13px; font-weight: 600;">
                        100%</div>

                    <!-- Image Wrapper for Pan/Zoom -->
                    <div id="opg-image-wrapper"
                        style="width: 100%; height: 600px; overflow: hidden; cursor: grab; display: flex; align-items: center; justify-content: center;">
                        <img id="opg-image" src="{{ opg }}" alt="OPG Image"
                            style="max-width: 100%; max-height: 100%; transition: transform 0.2s ease; user-select: none; -webkit-user-drag: none;">
                    </div>

                    <!-- Instructions -->
                    <div
                        style="padding: 10px; background: #1f2937; text-align: center; font-size: 13px; color: #9ca3af; border-top: 1px solid #374151;">
                        ðŸ’¡ <strong style="color: #fff;">Tip:</strong> Use mouse wheel to zoom in/out â€¢ Click and drag to
                        pan around the image
                    </div>
                </div>
            </div>
            {% endif %}
        </div>

        <div>
            <h4>Age Estimation</h4>
            <div class="form-group">
                <label for="estimated_age">Estimated Age (years):</label>
                <input type="number" step="0.1" id="estimated_age" name="estimated_age" required>
            </div>
        </div>
    </div>

    <div style="margin-top: 2rem; display: flex; gap: 1rem;">
        <button type="submit" class="btn">Submit Estimation</button>
        <button type="button" class="btn btn-secondary" id="cancel-estimation">Cancel</button>
    </div>
</form>

<style>
    #opg-image-wrapper.grabbing {
        cursor: grabbing !important;
    }
</style>

<script>
    (function () {
        // Simple image zoom and pan functionality
        const image = document.getElementById('opg-image');
        const wrapper = document.getElementById('opg-image-wrapper');
        const zoomLevelDisplay = document.getElementById('zoom-level');

        if (!image || !wrapper) return;

        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let lastTranslateX = 0;
        let lastTranslateY = 0;

        const MIN_SCALE = 1;
        const MAX_SCALE = 5;
        const ZOOM_STEP = 0.3;

        function updateTransform() {
            image.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            if (zoomLevelDisplay) {
                zoomLevelDisplay.textContent = Math.round(scale * 100) + '%';
            }
        }

        function zoom(delta, centerX, centerY) {
            const oldScale = scale;
            scale += delta;
            scale = Math.min(Math.max(scale, MIN_SCALE), MAX_SCALE);

            if (scale === MIN_SCALE) {
                translateX = 0;
                translateY = 0;
            } else if (centerX !== undefined && centerY !== undefined) {
                const rect = wrapper.getBoundingClientRect();
                const x = centerX - rect.left;
                const y = centerY - rect.top;

                const scaleChange = scale / oldScale;
                translateX = x - (x - translateX) * scaleChange;
                translateY = y - (y - translateY) * scaleChange;
            }

            updateTransform();
        }

        // Mouse wheel zoom
        wrapper.addEventListener('wheel', function (e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
            zoom(delta, e.clientX, e.clientY);
        }, { passive: false });

        // Mouse drag to pan
        wrapper.addEventListener('mousedown', function (e) {
            if (scale > MIN_SCALE) {
                isDragging = true;
                wrapper.classList.add('grabbing');
                startX = e.clientX;
                startY = e.clientY;
                lastTranslateX = translateX;
                lastTranslateY = translateY;
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', function (e) {
            if (isDragging) {
                translateX = lastTranslateX + (e.clientX - startX);
                translateY = lastTranslateY + (e.clientY - startY);
                updateTransform();
            }
        });

        document.addEventListener('mouseup', function () {
            if (isDragging) {
                isDragging = false;
                wrapper.classList.remove('grabbing');
            }
        });

        // Touch support for mobile
        let initialDistance = 0;
        let initialScale = 1;

        wrapper.addEventListener('touchstart', function (e) {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                initialScale = scale;
                e.preventDefault();
            } else if (e.touches.length === 1 && scale > MIN_SCALE) {
                isDragging = true;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                lastTranslateX = translateX;
                lastTranslateY = translateY;
            }
        }, { passive: false });

        wrapper.addEventListener('touchmove', function (e) {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const newScale = initialScale * (distance / initialDistance);
                scale = Math.min(Math.max(newScale, MIN_SCALE), MAX_SCALE);
                updateTransform();
                e.preventDefault();
            } else if (isDragging && e.touches.length === 1) {
                translateX = lastTranslateX + (e.touches[0].clientX - startX);
                translateY = lastTranslateY + (e.touches[0].clientY - startY);
                updateTransform();
                e.preventDefault();
            }
        }, { passive: false });

        wrapper.addEventListener('touchend', function () {
            isDragging = false;
        });
    })();

    // Cancel button
    const cancelBtn = document.getElementById('cancel-estimation');
    if (cancelBtn) {
        cancelBtn.addEventListener('click', function () {
            const modal = document.getElementById('estimation-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        });
    }
</script>